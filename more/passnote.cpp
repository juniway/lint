传纸条（一）

时间限制：2000 ms  |  内存限制：65535 KB
难度：5

描述
小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。

在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。


还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-1000的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。


输入
第一行输入N(0<N<100)表示待测数据组数。
每组测试数据输入的第一行有2个用空格隔开的整数m和n，表示班里有m行n列（2<=m,n<=50）。
接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度（不大于1000）。每行的n个整数之间用空格隔开。
输出
每组测试数据输出共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。
样例输入
1
3 3
0 3 9
2 8 5
5 7 0
样例输出
34

解题思路：将题目转化成同时从（1,1）到（m，n）的两条线路，要求这两条线路无交点。
最开始想用四维来表示状态线路1和线路2的位置状态，但是看别人说这样容易超时，于是定义成三维情况。
用k来表示每条线路到达当前位置时分别共走了多少步，x1表示线路1走到的x坐标位置，x2表示线路2的，
则间接表示了两条线路的y坐标，即k-x1或k-x2。状态表示出来后，状态转移就能表示出来了。

#include<bits/stdc++.h>
using namespace std;
const int maxn = 55;
int a[maxn][maxn];
int dp[maxn*2][maxn][maxn];
int mmax(int a,int b,int c,int d){
    int ret;
    ret = a > b ? a : b;
    ret = c > ret ? c : ret;
    ret = d > ret ? d : ret;
    return ret;
}

int main(){
    int t, n, m;
    scanf("%d", &t);
    while(t--){
        memset(dp, 0, sizeof(dp));
        scanf("%d%d", &m, &n);
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++)
                scanf("%d", &a[i][j]);
        }
        int y1, y2;
        for(int k = 3; k <= m+n; ++k){
            for(int x1 = 1; x1 <= m; ++x1){
                for(int x2 = 1; x2 <= m; ++x2){
                    y1 = k - x1;
                    y2 = k - x2;
                    if(y1 < 1 || y2 < 1 || y1 > n || y2 > n)  //非法状态
                        continue;
                    if(y1==y2)
                        continue;       //线路有重合
                    dp[k][x1][x2]=mmax(dp[k-1][x1][x2],dp[k-1][x1-1][x2],dp[k-1][x1][x2-1],dp[k-1][x1-1][x2-1])+a[x1][k-x1]+a[x2][k-x2];
                }
            }
        }
        cout << dp[n + m-1][m-1][m] << endl;
    }
    return 0;
}