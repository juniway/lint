

排序算法总结

 

1.插入排序

一般来说，插入排序 都采用in-place在数组上实现。具体算法描述如下：
从第一个元素开始，该元素可以认为已经被排序
取出下一个元素，在已经排序的元素序列中从后向前扫描
如果该元素（已排序）大于新元素，将该元素移到下一位置
重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
将新元素插入到该位置中
重复步骤2

如果比较操作 的代价比交换操作 大的话，可以采用二分查找法 来减少比较操作 的数目。该算法可以认为是插入排序 的一个变种，称为二分查找排序 。

上代码：

view plaincopy to clipboardprint?
void insertsort(int array[],int n)  
{  
    int i,j,temp;  
    for(i=1;i<n;i++)  
    {  
        temp=array[i];  
        j=i-1;  
        while((j>=0) && (array[j]>temp))  
        {  
            array[j+1]=array[j];  
            j--;  
        }  
        array[j+1]=temp;  
    }  
} 

算法复杂度：   

如果目标是把n个元素的序列升序排列，那么采用插入排序 存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需(n-1) 次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)/2 次。插入排序 的赋值操作是比较操作的次数加上(n-1) 次。平均来说插入排序 算法复杂度为O(n 2 )。因而，插入排序 不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序 还是一个不错的选择。

2.希尔排序

希尔排序（Shell Sort）又叫做缩小增量排序（diminishing increment sort），是一种很优秀的排序法，算法本身不难理解，也很容易实现，而且它的速度很快。

插入排序（Insertion Sort） 的一个重要的特点是，如果原始数据的大部分元素已经排序，那么插入排序的速度很快（因为需要移动的元素很少）。从这个事实我们可以想到，如果原始数据只有很少元素，那么排序的速度也很快。－－希尔排序就是基于这两点对插入排序作出了改进。

例如，有100个整数需要排序。
第一趟排序先把它分成50组，每组2个整数，分别排序。
第二趟排序再把经过第一趟排序后的100个整数分成25组，每组4个整数，分别排序。
第三趟排序再把前一次排序后的数分成12组，第组8个整数，分别排序。
照这样子分下去，最后一趟分成100组，每组一个整数，这就相当于一次插入排序。

由于开始时每组只有很少整数，所以排序很快。之后每组含有的整数越来越多，但是由于这些数也越来越有序，所以排序速度也很快。

下面用C语言实现希尔排序，用的是K&R里的算法，该算法结构很清晰。

view plaincopy to clipboardprint?
void shellsort(int array[],int n)  
{  
    int gap,i,j,temp;  
    for(gap=n/2;gap>0;gap/=2)  
    {  
        for(i=gap;i<n;i++)  
        {  
            for(j=i-gap;j>=0 && array[j]>array[j+gap];j-=gap)  
            {  
                temp=array[j];  
                array[j]=array[j+gap];  
                array[j+gap]=temp;  
            }  
        }  
    }  
} 

3.快速排序

快速排序使用分治法 （Divide and conquer）策略来把一个序列 （list）分为两个子序列（sub-lists）。

步骤为：
从数列中挑出一个元素，称为 "基准"（pivot），
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分割之后，该基准是它的最后位置。这个称为分割（partition） 操作。
递归 地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

view plaincopy to clipboardprint?
void quickSort(int a[],int low,int high)  
{     
    int i,j,pivot;  
    if(low<high)  
    {  
       pivot=a[low];  
       i=low;  
       j=high;  
       while(i<j)  
       {  
          while(i<j && a[j]>=pivot)  
              j--;  
          if(i<j)  
              a[i++]=a[j];  
          while(i<j && a[i]<=pivot)  
              i++;  
          if(i<j)  
              a[j--]=a[i];  
       }  
       a[i]=pivot;  
       quickSort(a,low,i-1);  
       quickSort(a,i+1,high);  
    }  
}  

4.堆排序

通常堆积树(heap)是通过一维阵列 来实现的。在起始阵列为 0 的情形中：
堆积树的根节点（即堆积树的最大值）存放在阵列位置 1 的地方

　　注意：不使用位置 0，否则左子树永远为 0 参考
节点i的左子节点在位置（2*i）
节点i的右子节点在位置（2*i+1）
节点i的父节点在位置floor((i-1)/2)

在堆积树的数据结构中，堆积树中的最大值总是位于根节点。堆积树中定义以下几种操作：
最大堆积调整（Max_Heapify）：将堆积树的末端子结点作调整,使得子结点永远小于父结点
建立最大堆积（Build_Max_Heap）：将堆积树所有数据重新排序
堆积排序（HeapSort）：移除位在第一个数据的根结点,并做最大堆积调整的递归 运算

view plaincopy to clipboardprint?
int parent(int i)  
{  
    return (int)floor(i/2);  
}  
int left(int i)  
{  
    return 2*i;  
}  
int right(int i)  
{  
    return 2*i+1;  
}  
void max_heapify(int a[],int i,int heap_size)  
{  
    int l=left(i);  
    int r=right(i);  
    int largest,temp;  
    if(l<heap_size && a[l]>a[i])  
    {  
        largest=l;  
    }  
    else  
    {  
        largest=i;  
    }  
    if(r<heap_size && a[r]>a[largest])  
    {  
        largest=r;  
    }  
    if(largest != i)  
    {  
        temp=a[i];  
        a[i]=a[largest];  
        a[largest]=temp;  
        max_heapify(a,largest,heap_size);  
    }  
}  
void build_max_heap(int a[])  
{  
    int i;  
    for(i=7;i>=0;i--)  
    {  
        max_heapify(a,i,7);  
    }  
}  
void print(int a[])  
{  
    int i;  
    for(i=0;i<7;i++)  
    {  
        printf("%3d",a[i]);  
    }  
    printf("/n");  
}  
void heapsort(int a[],int heap_size)  
{  
    build_max_heap(a);  
    int temp,i;  
    for(i=heap_size-1;i>=1;i--)  
    {  
        temp=a[0];  
        a[0]=a[i];  
        a[i]=temp;  
        heap_size=heap_size-1;  
        max_heapify(a,0,heap_size);  
    }  
    print(a);  
} 

5.归并排序

归并操作(merge)，也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。

归并操作的工作原理如下：
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
设定两个指针，最初位置分别为两个已经排序序列的起始位置
比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
重复步骤3直到某一指针达到序列尾
将另一序列剩下的所有元素直接复制到合并序列尾

view plaincopy to clipboardprint?
static void merge(int array[], int p, int q, int r)  
 {  
    int i,k;  
    int begin1,end1,begin2,end2;  
    int* temp = new int [r-p+1]; //申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列  
    begin1= p;     end1 = q; //设定两个指针，最初位置分别为两个已经排序序列的起始位置  
    begin2 = q+1;  end2 = r;  
   
    k = 0;  
    while((begin1 <= end1)&&( begin2 <= end2)) //比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置  
    {  
        if(array[begin1]<array[begin2])  
        {  
            temp[k] = array[begin1];  begin1++;   
        }  
        else  
        {  
            temp[k] = array[begin2];  begin2++;  
        }  
        k++;          
    }  
   
    while(begin1<=end1) //若第一个序列有剩余，直接拷贝出来粘到合并序列尾  
    {  
        temp[k++] = array[begin1++];  
    }  
    while(begin2<=end2) //若第二个序列有剩余，直接拷贝出来粘到合并序列尾  
    {  
        temp[k++] = array[begin2++];  
    }  
    for (i = 0; i < (r - p +1); i++) //将排序好的序列拷贝回数组中  
        array[p+i] = temp[i];  
    delete[] (temp);   
 }  

归并排序具体工作原理如下（假设序列共有n个元素）：
将序列每相邻两个数字进行归并操作（merge），形成f l o o r (n / 2) 个序列，排序后每个序列包含两个元素
将上述序列再次归并，形成f l o o r (n / 4) 个序列，每个序列包含四个元素
重复步骤2，直到所有元素排序完毕
view plaincopy to clipboardprint?
void merge_sort(int array[], unsigned int first, unsigned int last)
 
{
 
    int mid = 0;
 
    if(first<last)
 
    {
 
        mid = (first+last)/2;
 
        merge_sort(array, first, mid);
 
        merge_sort(array, mid+1,last);
 
        merge(array,first,mid,last);
 
    }
 
}

转载声明： 本文转自 http://blog.csdn.net/tqyou85/archive/2009/09/28/4600980.aspx

 

===============================================================================

 

排序算法总结

 

排序算法是一种基本并且常用的算法。由于实际工作中处理的数量巨大，所以排序算法对算法本身的速度要求很高。
    而一般我们所谓的算法的性能主要是指算法的复杂度，一般用O方法来表示。在后面我将给出详细的说明。
    对于排序的算法我想先做一点简单的介绍，也是给这篇文章理一个提纲。
    我将按照算法的复杂度，从简单到难来分析算法。
    第一部分是简单排序算法，后面你将看到他们的共同点是算法复杂度为O(N*N)（因为没有使用word,所以无法打出上标和下标）。
    第二部分是高级排序算法，复杂度为O(Log2(N))。这里我们只介绍一种算法。另外还有几种算法因为涉及树与堆的概念，所以这里不于讨论。
    第三部分类似动脑筋。这里的两种算法并不是最好的（甚至有最慢的），但是算法本身比较奇特，值得参考（编程的角度）。同时也可以让我们从另外的角度来认识这个问题。
    第四部分是我送给大家的一个餐后的甜点――一个基于模板的通用快速排序。由于是模板函数可以对任何数据类型排序（抱歉，里面使用了一些论坛专家的呢称）。
   
    现在，让我们开始吧：
   
一、简单排序算法
由于程序比较简单，所以没有加什么注释。所有的程序都给出了完整的运行代码，并在我的VC环境
下运行通过。因为没有涉及MFC和WINDOWS的内容，所以在BORLAND C++的平台上应该也不会有什么
问题的。在代码的后面给出了运行过程示意，希望对理解有帮助。
1.冒泡法：
这是最原始，也是众所周知的最慢的算法了。他的名字的由来因为它的工作看来象是冒泡：
#include <iostream.h>
void BubbleSort(int* pData,int Count)
{
    int iTemp;
    for(int i=1;i<Count;i++)
    {
        for(int j=Count-1;j>=i;j--)
        {
            if(pData[j]<pData[j-1])
            {
                iTemp = pData[j-1];
                pData[j-1] = pData[j];
                pData[j] = iTemp;
            }
        }
    }
}
void main()
{
    int data[] = {10,9,8,7,6,5,4};
    BubbleSort(data,7);
    for (int i=0;i<7;i++)
        cout<<data[i]<<" ";
    cout<<"/n";
}
倒序(最糟情况)
第一轮：10,9,8,7->10,9,7,8->10,7,9,8->7,10,9,8(交换3次)
第二轮：7,10,9,8->7,10,8,9->7,8,10,9(交换2次)
第一轮：7,8,10,9->7,8,9,10(交换1次)
循环次数：6次
交换次数：6次
其他：
第一轮：8,10,7,9->8,10,7,9->8,7,10,9->7,8,10,9(交换2次)
第二轮：7,8,10,9->7,8,10,9->7,8,10,9(交换0次)
第一轮：7,8,10,9->7,8,9,10(交换1次)
循环次数：6次
交换次数：3次
上面我们给出了程序段，现在我们分析它：这里，影响我们算法性能的主要部分是循环和交换，
显然，次数越多，性能就越差。从上面的程序我们可以看出循环的次数是固定的，为1+2+...+n-1。
写成公式就是1/2*(n-1)*n。
现在注意，我们给出O方法的定义：
    若存在一常量K和起点n0，使当n>=n0时，有f(n)<=K*g(n),则f(n) = O(g(n))。（呵呵，不要说没
学好数学呀，对于编程数学是非常重要的！！！）
现在我们来看1/2*(n-1)*n，当K=1/2，n0=1，g(n)=n*n时，1/2*(n-1)*n<=1/2*n*n=K*g(n)。所以f(n)
=O(g(n))=O(n*n)。所以我们程序循环的复杂度为O(n*n)。
    再看交换。从程序后面所跟的表可以看到，两种情况的循环相同，交换不同。其实交换本身同数据源的有序程度有极大的关系，当数据处于倒序的情况时，交换次数同循环一样（每次循环判断都会交换），复杂度为O(n*n)。当数据为正序，将不会有交换。复杂度为O(0)。乱序时处于中间状态。正是由于这样的原因，我们通常都是通过循环次数来对比算法。

2.交换法：
交换法的程序最清晰简单，每次用当前的元素一一的同其后的元素比较并交换。
#include <iostream.h>
void ExchangeSort(int* pData,int Count)
{
    int iTemp;
    for(int i=0;i<Count-1;i++)
    {
        for(int j=i+1;j<Count;j++)
        {
            if(pData[j]<pData[i])
            {
                iTemp = pData[i];
                pData[i] = pData[j];
                pData[j] = iTemp;
            }
        }
    }
}
void main()
{
    int data[] = {10,9,8,7,6,5,4};
    ExchangeSort(data,7);
    for (int i=0;i<7;i++)
        cout<<data[i]<<" ";
    cout<<"/n";
}
倒序(最糟情况)
第一轮：10,9,8,7->9,10,8,7->8,10,9,7->7,10,9,8(交换3次)
第二轮：7,10,9,8->7,9,10,8->7,8,10,9(交换2次)
第一轮：7,8,10,9->7,8,9,10(交换1次)
循环次数：6次
交换次数：6次
其他：
第一轮：8,10,7,9->8,10,7,9->7,10,8,9->7,10,8,9(交换1次)
第二轮：7,10,8,9->7,8,10,9->7,8,10,9(交换1次)
第一轮：7,8,10,9->7,8,9,10(交换1次)
循环次数：6次
交换次数：3次
从运行的表格来看，交换几乎和冒泡一样糟。事实确实如此。循环次数和冒泡一样也是1/2*(n-1)*n，所以算法的复杂度仍然是O(n*n)。由于我们无法给出所有的情况，所以只能直接告诉大家他们在交换上面也是一样的糟糕（在某些情况下稍好，在某些情况下稍差）。
3.选择法：
现在我们终于可以看到一点希望：选择法，这种方法提高了一点性能（某些情况下）这种方法类似我们人为的排序习惯：从数据中选择最小的同第一个值交换，在从省下的部分中选择最小的与第二个交换，这样往复下去。
#include <iostream.h>
void SelectSort(int* pData,int Count){
    int iTemp;
    int iPos;
    for(int i=0; i<Count-1; i++){
        iTemp = pData[i];
        iPos = i;
        for(int j=i+1;j<Count;j++){
            if(pData[j]<iTemp){
                iTemp = pData[j];
                iPos = j;
            }
        }
        pData[iPos] = pData[i];
        pData[i] = iTemp;
    }
}

void main(){
    int data[] = {10,9,8,7,6,5,4};
    SelectSort(data,7);
    for (int i=0;i<7;i++)
        cout<<data[i]<<" ";
    cout<<"/n";
}
倒序(最糟情况)
第一轮：10,9,8,7->(iTemp=9)10,9,8,7->(iTemp=8)10,9,8,7->(iTemp=7)7,9,8,10(交换1次)
第二轮：7,9,8,10->7,9,8,10(iTemp=8)->(iTemp=8)7,8,9,10(交换1次)
第一轮：7,8,9,10->(iTemp=9)7,8,9,10(交换0次)
循环次数：6次
交换次数：2次
其他：
第一轮：8,10,7,9->(iTemp=8)8,10,7,9->(iTemp=7)8,10,7,9->(iTemp=7)7,10,8,9(交换1次)
第二轮：7,10,8,9->(iTemp=8)7,10,8,9->(iTemp=8)7,8,10,9(交换1次)
第一轮：7,8,10,9->(iTemp=9)7,8,9,10(交换1次)
循环次数：6次
交换次数：3次
遗憾的是算法需要的循环次数依然是1/2*(n-1)*n。所以算法复杂度为O(n*n)。
我们来看他的交换。由于每次外层循环只产生一次交换（只有一个最小值）。所以f(n)<=n
所以我们有f(n)=O(n)。所以，在数据较乱的时候，可以减少一定的交换次数。

4.插入法：
插入法较为复杂，它的基本工作原理是抽出牌，在前面的牌中寻找相应的位置插入，然后继续下一张
#include <iostream.h>
void InsertSort(int* pData,int Count)
{
    int iTemp;
    int iPos;
    for(int i=1;i<Count;i++)
    {
        iTemp = pData[i];
        iPos = i-1;
        while((iPos>=0) && (iTemp<pData[iPos]))
        {
            pData[iPos+1] = pData[iPos];
            iPos--;
        }
        pData[iPos+1] = iTemp;
    }
}

void main()
{
    int data[] = {10,9,8,7,6,5,4};
    InsertSort(data,7);
    for (int i=0;i<7;i++)
        cout<<data[i]<<" ";
    cout<<"/n";
}
倒序(最糟情况)
第一轮：10,9,8,7->9,10,8,7(交换1次)(循环1次)
第二轮：9,10,8,7->8,9,10,7(交换1次)(循环2次)
第一轮：8,9,10,7->7,8,9,10(交换1次)(循环3次)
循环次数：6次
交换次数：3次
其他：
第一轮：8,10,7,9->8,10,7,9(交换0次)(循环1次)
第二轮：8,10,7,9->7,8,10,9(交换1次)(循环2次)
第一轮：7,8,10,9->7,8,9,10(交换1次)(循环1次)
循环次数：4次
交换次数：2次
上面结尾的行为分析事实上造成了一种假象，让我们认为这种算法是简单算法中最好的，其实不是，
因为其循环次数虽然并不固定，我们仍可以使用O方法。从上面的结果可以看出，循环的次数f(n)<=
1/2*n*(n-1)<=1/2*n*n。所以其复杂度仍为O(n*n)（这里说明一下，其实如果不是为了展示这些简单
排序的不同，交换次数仍然可以这样推导）。现在看交换，从外观上看，交换次数是O(n)（推导类似
选择法），但我们每次要进行与内层循环相同次数的‘=’操作。正常的一次交换我们需要三次‘=’
而这里显然多了一些，所以我们浪费了时间。
最终，我个人认为，在简单排序算法中，选择法是最好的。

二、高级排序算法：
高级排序算法中我们将只介绍这一种，同时也是目前我所知道（我看过的资料中）的最快的。
它的工作看起来仍然象一个二叉树。首先我们选择一个中间值middle程序中我们使用数组中间值，然后
把比它小的放在左边，大的放在右边（具体的实现是从两边找，找到一对后交换）。然后对两边分别使
用这个过程（最容易的方法――递归）。
1.快速排序：
#include <iostream.h>
void run(int* pData,int left,int right)
{
    int i,j;
    int middle,iTemp;
    i = left;
    j = right;
    middle = pData[(left+right)/2];  //求中间值
    do{
        while((pData[i]<middle) && (i<right))//从左扫描大于中值的数
            i++;          
        while((pData[j]>middle) && (j>left))//从右扫描大于中值的数
            j--;
        if(i<=j)//找到了一对值
        {
            //交换
            iTemp = pData[i];
            pData[i] = pData[j];
            pData[j] = iTemp;
            i++;
            j--;
        }
    }while(i<=j);//如果两边扫描的下标交错，就停止（完成一次）
    //当左边部分有值(left<j)，递归左半边
    if(left<j)
        run(pData,left,j);
    //当右边部分有值(right>i)，递归右半边
    if(right>i)
        run(pData,i,right);
}
void QuickSort(int* pData,int Count)
{
    run(pData,0,Count-1);
}
void main()
{
    int data[] = {10,9,8,7,6,5,4};
    QuickSort(data,7);
    for (int i=0;i<7;i++)
        cout<<data[i]<<" ";
    cout<<"/n";
}
这里我没有给出行为的分析，因为这个很简单，我们直接来分析算法：首先我们考虑最理想的情况
1.数组的大小是2的幂，这样分下去始终可以被2整除。假设为2的k次方，即k=log2(n)。
2.每次我们选择的值刚好是中间值，这样，数组才可以被等分。
第一层递归，循环n次，第二层循环2*(n/2)......
所以共有n+2(n/2)+4(n/4)+...+n*(n/n) = n+n+n+...+n=k*n=log2(n)*n
所以算法复杂度为O(log2(n)*n)
其他的情况只会比这种情况差，最差的情况是每次选择到的middle都是最小值或最大值，那么他将变
成交换法（由于使用了递归，情况更糟）。但是你认为这种情况发生的几率有多大？？呵呵，你完全
不必担心这个问题。实践证明，大多数的情况，快速排序总是最好的。
如果你担心这个问题，你可以使用堆排序，这是一种稳定的O(log2(n)*n)算法，但是通常情况下速度要慢于快速排序（因为要重组堆）。
三、其他排序
1.双向冒泡：
通常的冒泡是单向的，而这里是双向的，也就是说还要进行反向的工作。
代码看起来复杂，仔细理一下就明白了，是一个来回震荡的方式。
写这段代码的作者认为这样可以在冒泡的基础上减少一些交换（我不这么认为，也许我错了）。
反正我认为这是一段有趣的代码，值得一看。
#include <iostream.h>
void Bubble2Sort(int* pData,int Count)
{
    int iTemp;
    int left = 1;
    int right =Count -1;
    int t;
    do
    {
        //正向的部分
        for(int i=right;i>=left;i--)
        {
            if(pData[i]<pData[i-1])
            {
                iTemp = pData[i];
                pData[i] = pData[i-1];
                pData[i-1] = iTemp;
                t = i;
            }
        }
        left = t+1;
        //反向的部分
        for(i=left;i<right+1;i++)
        {
            if(pData[i]<pData[i-1])
            {
                iTemp = pData[i];
                pData[i] = pData[i-1];
                pData[i-1] = iTemp;
                t = i;
            }
        }
        right = t-1;
    }while(left<=right);
}
void main()
{
    int data[] = {10,9,8,7,6,5,4};
    Bubble2Sort(data,7);
    for (int i=0;i<7;i++)
        cout<<data[i]<<" ";
    cout<<"/n";
}
2.SHELL排序
这个排序非常复杂，看了程序就知道了。
首先需要一个递减的步长，这里我们使用的是9、5、3、1（最后的步长必须是1）。
工作原理是首先对相隔9-1个元素的所有内容排序，然后再使用同样的方法对相隔5-1个元素的排序
以次类推。
#include <iostream.h>
void ShellSort(int* pData,int Count)
{
    int step[4];
    step[0] = 9;
    step[1] = 5;
    step[2] = 3;
    step[3] = 1;
    int iTemp;
    int k,s,w;
    for(int i=0;i<4;i++)
    {
        k = step[i];
        s = -k;
        for(int j=k;j<Count;j++)
        {
            iTemp = pData[j];
            w = j-k;//求上step个元素的下标
            if(s ==0)
            {
                s = -k;
                s++;
                pData[s] = iTemp;
            }
            while((iTemp<pData[w]) && (w>=0) && (w<=Count))
            {
                pData[w+k] = pData[w];
                w = w-k;
            }
            pData[w+k] = iTemp;
        }
    }
}
void main()
{
    int data[] = {10,9,8,7,6,5,4,3,2,1,-10,-1};
    ShellSort(data,12);
    for (int i=0;i<12;i++)
        cout<<data[i]<<" ";
    cout<<"/n";
}
呵呵，程序看起来有些头疼。不过也不是很难，把s==0的块去掉就轻松多了，这里是避免使用0
步长造成程序异常而写的代码。这个代码我认为很值得一看。
这个算法的得名是因为其发明者的名字D.L.SHELL。依照参考资料上的说法：“由于复杂的数学原因
避免使用2的幂次步长，它能降低算法效率。”另外算法的复杂度为n的1.2次幂。同样因为非常复杂并
“超出本书讨论范围”的原因（我也不知道过程），我们只有结果了。

四、基于模板的通用排序：
这个程序我想就没有分析的必要了，大家看一下就可以了。不明白可以在论坛上问。
MyData.h文件
///////////////////////////////////////////////////////
class CMyData 
{
public:
    CMyData(int Index,char* strData);
    CMyData();
    virtual ~CMyData();
    int m_iIndex;
    int GetDataSize(){ return m_iDataSize; };
    const char* GetData(){ return m_strDatamember; };
    //这里重载了操作符：
    CMyData& operator =(CMyData &SrcData);
    bool operator <(CMyData& data );
    bool operator >(CMyData& data );
private:
    char* m_strDatamember;
    int m_iDataSize;
};
////////////////////////////////////////////////////////
MyData.cpp文件
////////////////////////////////////////////////////////
CMyData::CMyData():
m_iIndex(0),
m_iDataSize(0),
m_strDatamember(NULL)
{
}
CMyData::~CMyData()
{
    if(m_strDatamember != NULL)
        delete[] m_strDatamember;
    m_strDatamember = NULL;
}
CMyData::CMyData(int Index,char* strData):
m_iIndex(Index),
m_iDataSize(0),
m_strDatamember(NULL)
{
    m_iDataSize = strlen(strData);
    m_strDatamember = new char[m_iDataSize+1];
    strcpy(m_strDatamember,strData);
}
CMyData& CMyData::operator =(CMyData &SrcData)
{
    m_iIndex = SrcData.m_iIndex;
    m_iDataSize = SrcData.GetDataSize();
    m_strDatamember = new char[m_iDataSize+1];
    strcpy(m_strDatamember,SrcData.GetData());
    return *this;
}
bool CMyData::operator <(CMyData& data )
{
    return m_iIndex<data.m_iIndex;
}
bool CMyData::operator >(CMyData& data )
{
    return m_iIndex>data.m_iIndex;
}
///////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
//主程序部分
#include <iostream.h>
#include "MyData.h"
template <class T>
void run(T* pData,int left,int right)
{
    int i,j;
    T middle,iTemp;
    i = left;
    j = right;
    //下面的比较都调用我们重载的操作符函数
    middle = pData[(left+right)/2];  //求中间值
    do{
        while((pData[i]<middle) && (i<right))//从左扫描大于中值的数
            i++;          
        while((pData[j]>middle) && (j>left))//从右扫描大于中值的数
            j--;
        if(i<=j)//找到了一对值
        {
            //交换
            iTemp = pData[i];
            pData[i] = pData[j];
            pData[j] = iTemp;
            i++;
            j--;
        }
    }while(i<=j);//如果两边扫描的下标交错，就停止（完成一次）
    //当左边部分有值(left<j)，递归左半边
    if(left<j)
        run(pData,left,j);
    //当右边部分有值(right>i)，递归右半边
    if(right>i)
        run(pData,i,right);
}
template <class T>
void QuickSort(T* pData,int Count)
{
    run(pData,0,Count-1);
}
void main()
{
    CMyData data[] = {
        CMyData(8,"xulion"),
        CMyData(7,"sanzoo"),
        CMyData(6,"wangjun"),
        CMyData(5,"VCKBASE"),
        CMyData(4,"jacky2000"),
        CMyData(3,"cwally"),
        CMyData(2,"VCUSER"),
        CMyData(1,"isdong")
    };
    QuickSort(data,8);
    for (int i=0;i<8;i++)
        cout<<data[i].m_iIndex<<"  "<<data[i].GetData()<<"/n";
    cout<<"/n";
}

 

转载声明： 本文转自 http://lxh1155.blog.163.com/blog/static/9311430200992113625652/

 

==============================================================================

 

各种排序算法总结

 

一、选择排序

1. 基本思想：

　　每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。

2. 排序过程：

【示例】：

   初始关键字 [49 38 65 97 76 13 27 49]

第一趟排序后 13 ［38 65 97 76 49 27 49]

第二趟排序后 13 27 ［65 97 76 49 38 49]

第三趟排序后 13 27 38 [97 76 49 65 49]

第四趟排序后 13 27 38 49 [49 97 65 76]

第五趟排序后 13 27 38 49 49 [97 97 76]

第六趟排序后 13 27 38 49 49 76 [76 97]

第七趟排序后 13 27 38 49 49 76 76 [ 97]

最后排序结果 13 27 38 49 49 76 76 97

3.

void selectionSort(Type* arr,long len)

{

   long i=0,j=0;/*iterator value*/

   long maxPos;

   assertF(arr!=NULL,"In InsertSort sort,arr is NULL/n");

   for(i=len-1;i>=1;i--)

   {

             maxPos=i;

             for(j=0;j<i;j++)

                  if(arr[maxPos]<arr[j])maxPos=j;

             if(maxPos!=i)swapArrData(arr,maxPos,i);

   }

}

选择排序法的第一层循环从起始元素开始选到倒数第二个元素,主要是在每次进入的第二层循环之前,将外层循环的下标赋值给临时变量,接下来的第二层循环中,如果发现有比这个最小位置处的元素更小的元素,则将那个更小的元素的下标赋给临时变量,最后,在二层循环退出后,如果临时变量改变,则说明,有比当前外层循环位置更小的元素,需要将这两个元素交换.

二.直接插入排序

插入排序（Insertion Sort）的基本思想是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子文件中的适当位置，直到全部记录插入完成为止。

直接插入排序

　　直接插入排序（Straight Insertion Sort）：将一个记录插入到排好序的有序表中，从而得到一个新的、记录数增1的有序表。

直接插入排序算法



　　哨兵（监视哨）有两个作用：一是作为临变量存放R[i]（当前要进行比较的关键字）的副本；二是在查找循环中用来监视下标变量j是否越界。

　

　　当文件的初始状态不同时，直接插入排序所耗费的时间是有很大差异的。最好情况是文件初态为正序，此时算法的时间复杂度为O(n)，最坏情况是文件初态为反序，相应的时间复杂度为O(n2)，算法的平均时间复杂度是O(n2)。算法的辅助空间复杂度是O(1)，是一个就地排序。

直接插入排序是稳定的排序方法。

三. 冒泡排序

[算法思想]：将被排序的记录数组R[1..n]垂直排列，每个记录R[i]看作是重量为R[i].key的气泡。根据轻气泡不能在重气泡之下的原则，从下往上扫描数组R：凡扫描到违反本原则的轻气泡，就使其向上"飘浮"。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。

 

    [算法]：

     void BubbleSort(SeqList R) {

     //R（l..n)是待排序的文件，采用自下向上扫描，对R做冒泡排序

         int i，j；

         Boolean exchange； //交换标志

         for(i=1;i<n;i++){ //最多做n-1趟排序

             exchange=FALSE； //本趟排序开始前，交换标志应为假

             for(j=n-1;j>=i；j--) //对当前无序区R[i..n]自下向上扫描

                 if(R[j+1].key<R[j].key){//交换记录

                     R[0]=R[j+1]； //R[0]不是哨兵，仅做暂存单元

                     R[j+1]=R[j]；

                     R[j]=R[0]；

                     exchange=TRUE； //发生了交换，故将交换标志置为真

                 }

             if(!exchange) return；//本趟排序未发生交换，提前终止算法

         } //endfor(外循环)

     } //BubbleSort

    [分析]：起泡排序的结束条件为：最后一趟没有进行“交换”。从起泡排序的过程可见，起泡排序是一个增加有序序列长度的过程，也是一个缩小无序序列长度的过程，每经过一趟起泡，无序序列的长度只缩小1。 [算法思想]：将被排序的记录数组R[1..n]垂直排列，每个记录R[i]看作是重量为R[i].key的气泡。根据轻气泡不能在重气泡之下的原则，从下往上扫描数组R：凡扫描到违反本原则的轻气泡，就使其向上"飘浮"。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。

 

    [算法]：

     void BubbleSort(SeqList R) {

     //R（l..n)是待排序的文件，采用自下向上扫描，对R做冒泡排序

         int i，j；

         Boolean exchange； //交换标志

         for(i=1;i<n;i++){ //最多做n-1趟排序

             exchange=FALSE； //本趟排序开始前，交换标志应为假

             for(j=n-1;j>=i；j--) //对当前无序区R[i..n]自下向上扫描

                 if(R[j+1].key<R[j].key){//交换记录

                     R[0]=R[j+1]； //R[0]不是哨兵，仅做暂存单元

                     R[j+1]=R[j]；

                     R[j]=R[0]；

                     exchange=TRUE； //发生了交换，故将交换标志置为真

                 }

             if(!exchange) return；//本趟排序未发生交换，提前终止算法

         } //endfor(外循环)

     } //BubbleSort

    [分析]：起泡排序的结束条件为：最后一趟没有进行“交换”。从起泡排序的过程可见，起泡排序是一个增加有序序列长度的过程，也是一个缩小无序序列长度的过程，每经过一趟起泡，无序序列的长度只缩小1。

四. 希尔排序

基本思想：

　    先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为dl的倍数的记录放在同一个组中。先在各组内进行直接插人排序；然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量dt=1(dt<dt-l<…<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。

    　该方法实质上是一种分组插入方法。

给定实例的shell排序的排序过程

    　假设待排序文件有10个记录，其关键字分别是：

        49，38，65，97，76，13，27，49，55，04。

    　增量序列的取值依次为：

        5，3，1

Shell排序的算法实现

1． 不设监视哨的算法描述

void ShellPass(SeqList R，int d)

   {//希尔排序中的一趟排序，d为当前增量

     for(i=d+1;i<=n；i++) //将R[d+1．．n]分别插入各组当前的有序区

       if(R[i].key<R[i-d].key){

         R[0]=R[i];j=i-d； //R[0]只是暂存单元，不是哨兵

         do {//查找R[i]的插入位置

            R[j+d]；=R[j]； //后移记录

            j=j-d； //查找前一记录

         }while(j>0&&R[0].key<R[j].key)；

         R[j+d]=R[0]； //插入R[i]到正确的位置上

       } //endif

   } //ShellPass

void ShellSort(SeqList R)

   {

    int increment=n； //增量初值，不妨设n>0

    do {

          increment=increment/3+1； //求下一增量

          ShellPass(R，increment)； //一趟增量为increment的Shell插入排序

       }while(increment>1)

    } //ShellSort

注意：

　    当增量d=1时，ShellPass和InsertSort基本一致，只是由于没有哨兵而在内循环中增加了一个循环判定条件"j>0"，以防下标越界。

2．设监视哨的shell排序算法

算法分析

1．增量序列的选择

    　Shell排序的执行时间依赖于增量序列。

    　好的增量序列的共同特征：

　　① 最后一个增量必须为1；

　　② 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。

    　有人通过大量的实验，给出了目前较好的结果：当n较大时，比较和移动的次数约在nl.25到1.6n1.25之间。

2．Shell排序的时间性能优于直接插入排序

    　希尔排序的时间性能优于直接插入排序的原因：

　　①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。

　　②当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。

　　③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。

    　因此，希尔排序在效率上较直接插人排序有较大的改进。

3．稳定性

    　希尔排序是不稳定的。参见上述实例，该例中两个相同关键字49在排序前后的相对次序发生了变化。

五. 堆排序

1、 堆排序定义

    　n个关键字序列Kl，K2，…，Kn称为堆，当且仅当该序列满足如下性质(简称为堆性质)：

    　(1) ki≤K2i且ki≤K2i+1 或(2)Ki≥K2i且ki≥K2i+1(1≤i≤  )

    　若将此序列所存储的向量R[1..n]看做是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶结点的关键字均不大于(或不小于)其左右孩子(若存在)结点的关键字。

【例】关键字序列(10，15，56，25，30，70)和(70，56，30，25，15，10)分别满足堆性质(1)和(2)，故它们均是堆，其对应的完全二叉树分别如小根堆示例和大根堆示例所示。

2、大根堆和小根堆

    　根结点(亦称为堆顶)的关键字是堆里所有结点关键字中最小者的堆称为小根堆。

    　根结点(亦称为堆顶)的关键字是堆里所有结点关键字中最大者，称为大根堆。

注意：

    　①堆中任一子树亦是堆。

    　 ②以上讨论的堆实际上是二叉堆(Binary Heap)，类似地可定义k叉堆。

3、堆排序特点

    　堆排序(HeapSort)是一树形选择排序。

    　堆排序的特点是：在排序过程中，将R[l..n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系【参见二叉树的顺序存储结构】，在当前无序区中选择关键字最大(或最小)的记录。

4、堆排序与直接插入排序的区别

    　直接选择排序中，为了从R[1..n]中选出关键字最小的记录，必须进行n-1次比较，然后在R[2..n]中选出关键字最小的记录，又需要做n-2次比较。事实上，后面的n-2次比较中，有许多比较可能在前面的n-1次比较中已经做过，但由于前一趟排序时未保留这些比较结果，所以后一趟排序时又重复执行了这些比较操作。

    　堆排序可通过树形结构保存部分比较结果，可减少比较次数。

 

5、堆排序

    堆排序利用了大根堆(或小根堆)堆顶记录的关键字最大(或最小)这一特征，使得在当前无序区中选取最大(或最小)关键字的记录变得简单。

（1）用大根堆排序的基本思想

① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区

② 再将关键字最大的记录R[1](即堆顶)和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key

③ 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。

    ……

直到无序区只有一个元素为止。

（2）大根堆排序算法的基本操作：

① 初始化操作：将R[1..n]构造为初始堆；

② 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换，然后将新的无序区调整为堆(亦称重建堆)。

注意：

①只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。

②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。堆排序和直接选择排序相反：在任何时刻，堆排序中无序区总是在有序区之前，且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。

（3）堆排序的算法：

void HeapSort(SeqIAst R)

   { //对R[1..n]进行堆排序，不妨用R[0]做暂存单元

    int i；

    BuildHeap(R)； //将R[1-n]建成初始堆

    for(i=n;i>1；i--){ //对当前无序区R[1..i]进行堆排序，共做n-1趟。

      R[0]=R[1]；R[1]=R[i];R[i]=R[0]； //将堆顶和堆中最后一个记录交换

　    Heapify(R，1，i-1)； //将R[1..i-1]重新调整为堆，仅有R[1]可能违反堆性质

     } //endfor

   } //HeapSort

（4） BuildHeap和Heapify函数的实现

　因为构造初始堆必须使用到调整堆的操作，先讨论Heapify的实现。

① Heapify函数思想方法

　每趟排序开始前R[l..i]是以R[1]为根的堆，在R[1]与R[i]交换后，新的无序区R[1..i-1]中只有R[1]的值发生了变化，故除R[1]可能违反堆性质外，其余任何结点为根的子树均是堆。因此，当被调整区间是R[low..high]时，只须调整以R[low]为根的树即可。

"筛选法"调整堆

　 R[low]的左、右子树(若存在)均已是堆，这两棵子树的根R[2low]和R[2low+1]分别是各自子树中关键字最大的结点。若R[low].key不小于这两个孩子结点的关键字，则R[low]未违反堆性质，以R[low]为根的树已是堆，无须调整；否则必须将R[low]和它的两个孩子结点中关键字较大者进行交换，即R[low]与R[large](R[large].key=max(R[2low].key，R[2low+1].key))交换。交换后又可能使结点R[large]违反堆性质，同样由于该结点的两棵子树(若存在)仍然是堆，故可重复上述的调整过程，对以R[large]为根的树进行调整。此过程直至当前被调整的结点已满足堆性质，或者该结点已是叶子为止。上述过程就象过筛子一样，把较小的关键字逐层筛下去，而将较大的关键字逐层选上来。因此，有人将此方法称为"筛选法"。

②BuildHeap的实现

　　要将初始文件R[l..n]调整为一个大根堆，就必须将它所对应的完全二叉树中以每一结点为根的子树都调整为堆。

　　显然只有一个结点的树是堆，而在完全二叉树中，所有序号 的结点都是叶子，因此以这些结点为根的子树均已是堆。这样，我们只需依次将以序号为 ，  -1，…，1的结点作为根的子树都调整为堆即可。

    　 具体算法【参见教材】。

5、大根堆排序实例

    　对于关键字序列(42，13，24，91，23，16，05，88)，在建堆过程中完全二叉树及其存储结构的变化情况参见。

6、 算法分析

    　堆排序的时间，主要由建立初始堆和反复重建堆这两部分的时间开销构成，它们均是通过调用Heapify实现的。

   　 堆排序的最坏时间复杂度为O(nlgn)。堆排序的平均性能较接近于最坏性能。

    　由于建初始堆所需的比较次数较多，所以堆排序不适宜于记录数较少的文件。

    　堆排序是就地排序，辅助空间为O(1)，

    　它是不稳定的排序方法。

六. 快速排序

快速排序的基本思路是：首先我们选择一个中间值middle（程序中我们可使用数组中间值），把比中间值小的放在其左边，比中间值大的放在其右边。由于这个排序算法较复杂，我们先给出其进行一次排序的程序框架（从各类数据结构教材中可得）：

void QuickSort(int *pData, int left, int right)

{

　int i, j;

　int middle, iTemp;

　i = left;

　j = right;

　middle = pData[(left + right) / 2]; //求中间值

　do

　{

　　while ((pData[i] < middle) && (i < right)) //从左扫描大于中值的数

　　　i++;

　　while ((pData[j] > middle) && (j > left)) //从右扫描小于中值的数

　　　j--;

　　if (i <= j) //找到了一对值

　　{

　　　//交换

　　　iTemp = pData[i];

　　　pData[i] = pData[j];

　　　pData[j] = iTemp;

　　　i++;

　　　j--;

　　}

　} while (i <= j) ; //如果两边扫描的下标交错，就停止（完成一次）

　//当左边部分有值(left<j)，递归左半边

　if(left<j)

　　QuickSort (pData,left,j);

　　//当右边部分有值(right>i)，递归右半边

　if(right>i)

　　QuickSort (pData,i,right);

}

对于n个成员，快速排序法的比较次数大约为n*logn 次，交换次数大约为(n*logn)/6次。如果n为100，冒泡法需要进行4950 次比较，而快速排序法仅需要200 次，快速排序法的效率的确很高。快速排序法的性能与中间值的选定关系密切，如果每一次选择的中间值都是最大值（或最小值），该算法的速度就会大大下降。快速排序算法最坏情况下的时间复杂度为O(n2)，而平均时间复杂度为O(n*logn)。

七. 合并排序

f明

之前所介B的排序法都是在同一列中的排序，考]今日有晒P或晒P以上的Y料，它可能是不同列中的Y料，或是不同n案中的Y料，如何樗M行排序？

解法

可以使用合闩判蚍ǎ合闩判蚍基本是晒P已排序的Y料合KM行排序，如果所x入的Y料尚未排序，可以先利用其它的排序方式硖理@晒PY料，然後再⑴判蚝玫倪@晒PY料合恪

有人道，如果晒PY料本身就o排序序，何不⑺有的Y料x入，再一次M行排序？排序的精神是量利用Y料已排序的部份，砑涌炫判虻男率，小PY料的排序^榭焖伲如果小PY料排序完成之後，再合闾理r，因晒PY料都有排序了，所有在合闩判r比渭x入所有的Y料再一次排序淼挠行率。

那N可不可以直接使用合闩判蚍ū旧硖理整排序的幼鳎慷不佑玫狡渌的排序方式？答案是肯定的，只要⑺有的底植嗟姆等分，直到最後剩一底橹梗然後再反^聿嗟暮悖就如下D所示：

 

不^基本上分割又花去~外的rg，不如使用其它^好的排序法砼判蛐」PY料，再使用合闩判淼挠行率。

下面@程式例，我使用快速排序法硖理小PY料排序，然後再使用合闩判蚍ㄌ理合愕幼鳌

例子
 
C

#include <stdio.h>

#include <stdlib.h>

#include <time.h>

#define MAX1 10

#define MAX2 10

#define SWAP(x,y) {int t; t = x; x = y; y = t;}

int partition(int[], int, int);

void quicksort(int[], int, int);

void mergesort(int[], int, int[], int, int[]);

int main(void) {

int number1[MAX1] = {0};

int number2[MAX1] = {0};

int number3[MAX1+MAX2] = {0};

int i, num;

srand(time(NULL));

printf("排序前：");

printf("/nnumber1[]：");

for(i = 0; i < MAX1; i++) {

number1[i] = rand() % 100;

printf("%d ", number1[i]);

}

printf("/nnumber2[]：");

for(i = 0; i < MAX2; i++) {

number2[i] = rand() % 100;

printf("%d ", number2[i]);

}

// 先排序晒PY料

quicksort(number1, 0, MAX1-1);

quicksort(number2, 0, MAX2-1);

printf("/n排序後：");

printf("/nnumber1[]：");

for(i = 0; i < MAX1; i++)

printf("%d ", number1[i]);

printf("/nnumber2[]：");

for(i = 0; i < MAX2; i++)

printf("%d ", number2[i]);

// 合闩判

mergesort(number1, MAX1, number2, MAX2, number3);

printf("/n合汜幔");

for(i = 0; i < MAX1+MAX2; i++)

printf("%d ", number3[i]);

printf("/n");

return 0;

}

int partition(int number[], int left, int right) {

int i, j, s;

s = number[right];

i = left - 1;

for(j = left; j < right; j++) {

if(number[j] <= s) {

i++;

SWAP(number[i], number[j]);

}

}

SWAP(number[i+1], number[right]);

return i+1;

}

void quicksort(int number[], int left, int right) {

int q;

if(left < right) {

q = partition(number, left, right);

quicksort(number, left, q-1);

quicksort(number, q+1, right);

}

}

void mergesort(int number1[], int M, int number2[],

int N, int number3[]) {

int i = 0, j = 0, k = 0;

while(i < M && j < N) {

if(number1[i] <= number2[j])

number3[k++] = number1[i++];

else

number3[k++] = number2[j++];

}

while(i < M)

number3[k++] = number1[i++];

while(j < N)

number3[k++] = number2[j++];

}

 
Java

 

public class MergeSort {

public static int[] sort(int[] number1,

int[] number2) {

int[] number3 =

new int[number1.length + number2.length];

int i = 0, j = 0, k = 0;

while(i < number1.length && j < number2.length) {

if(number1[i] <= number2[j])

number3[k++] = number1[i++];

else

number3[k++] = number2[j++];

}

while(i < number1.length)

number3[k++] = number1[i++];

while(j < number2.length)

number3[k++] = number2[j++];

return number3;

}

}

八。基数排序

基数排序是根据组成关键字的各位值，用"分配"和"收集"的方法进行排序。例如，把扑克牌的排序看成由花色和面值两个数据项组成的主关键字排序。

　　花色：梅花<方块<红心<黑桃

　　面值：2<3<4<...<10<J<Q<K<A

　　若要将一副扑克牌排成下列次序：

　　梅花2,...,梅花A,方块2,...,方块A,红心2,...,红心A,黑桃2,...,黑桃A。

　　有两种排序方法：

　　一、先按花色分成四堆，把各堆收集起来；然后对每堆按面值由小到大排列，再按花色从小到大按堆收叠起来。----称为"最高位优先"(MSD)法。

　　二、先按面值由小到大排列成13堆,然后从小到大收集起来；再按花色不同分成四堆,最后顺序收集起来。----称为"最低位优先"(LSD)法。

　　[例] 设记录键值序列为{88,71,60,31,87,35,56,18}，用基数排序(LSD)。如图所示：其中f[i]、e[i]为按位分配面值为i的队列的队头和队尾指针。

   #define D 3

   typedef struct

   { int key;

     float data;

     int link;

   } JD

 key    data    link


int jspx(JD r[],int n)

{ /*链式存储表示的基数排序*/

   int i,j,k,t,p,rd,rg,f[10],e[10];

   /*p为r[]的下标,rd,rg为比例因子,f[j],e[j]是代码为j的队的首尾指针*/

   for(i=1;i<n;i++) r[i].link=i+1;

   r[n].link=0;

   p=1;rd=1;rg=10;

   for(i=1;i<=D;i++)

   { for(j=0;j<10;j++) { f[j]=0;e[j]=0; } /*各队列初始化*/

     do /*按位分配--分到各队列中*/

     { k=(r[p].key%rg)/rd; /*取键值的某一位*/

       if(f[k]==0) f[k]=p;

       else r[e[k]].link=p; /*有重复值--修改链接*/

       e[k]=p;

       p=r[p].link; /*取下一个结点的地址*/

     }while(p>0);

     j=0; /*按位收集--调整分配后的链接*/

     while(f[j]==0) j=j+1;

     p=f[j];t=e[j];

     for(k=j+1;k<10;k++)

       if(f[k]>0){ r[t].link=f[k];t=e[k]; }/*调整链接*/

     r[t].link=0; /*链尾为0*/

     rg=rg*10;rd=rd*10; /*提高一位*/

   }

   return(p); /*返回有序链表的首地址*/

九 枚举排序

将每个记录项与其他诸项比较计算出小于该项的记录个数，以确定该项的位置。

 

转载声明： 本文转自 http://student.csdn.net/space.php?uid=49357&do=blog&id=11377
分享到：
上一篇：常见排序算法的稳定性分析和结论
下一篇：各种经典算法总结

      常见排序算法的稳定性分析和结论

 

这几天笔试了好几次了，连续碰到一个关于常见排序算法稳定性判别的问题，往往还是多选，对于我以及和我一样拿不准的同学可不是一个能轻易下结论的题目，当然如果你笔试之前已经记住了数据结构书上哪些是稳定的，哪些不是稳定的，做起来应该可以轻松搞定。本文是针对老是记不住这个或者想真正明白到底为什么是稳定或者不稳定的人准备的。

      首先，排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj, Ai原来在位置前，排序后Ai还是要在Aj位置前。

     其次，说一下稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素其顺序再高位也相同时是不会改变的。另外，如果排序算法稳定，对基于比较的排序算法而言，元素交换的次数可能会少一些(个人感觉，没有证实)。

     回到主题，现在分析一下常见的排序算法的稳定性，每个都给出简单的理由。

   (1)冒泡排序

        冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

(2)选择排序

      选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

(3)插入排序
     插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。


(4)快速排序
    快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j, 交换a[i]和a[j],重复上面的过程，直到i>j。交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11，现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。


(5)归并排序
    归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。

(6)基数排序
   基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

(7)希尔排序(shell)
    希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

(8)堆排序
   我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, ...1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。

 


综上，得出结论: 选择排序、快速排序、希尔排序、堆排序不是稳定的排序算法，而冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法。还有一些排序算法我没有进行

分析，欢迎和各位朋友一起分析、交流。

 

转载声明： 本文转自 http://tcmrabbit.javaeye.com/blog/464541

 

=================================================================

 

几种常用排序算法总结

 

所谓排序，就是要整理文件中的记录，使之按关键字递增(或递减)次序排列起来。当待排序记录的关键字都不相同时，排序结果是惟一的，否则排序结果不惟一。
    在待排序的文件中，若存在多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，该排序方法是稳定的；若具有相同关键字的记录之间的相对次序发生改变，则称这种排序方法是不稳定的。
    要注意的是，排序算法的稳定性是针对所有输入实例而言的。即在所有可能的输入实例中，只要有一个实例使得算法不满足稳定性要求，则该排序算法就是不稳定的。


一.插入排序
    插入排序的基本思想是每步将一个待排序的记录按其排序码值的大小，插到前面已经排好的文件中的适当位置，直到全部插入完为止。插入排序方法主要有直接插入排序和希尔排序。

①.直接插入排序(稳定)
    接插入排序的过程为：在插入第i个记录时，R1,R2,..Ri-1已经排好序，将第i个记录的排序码Ki依次和R1,R2,..,Ri-1的排序码逐个进行比较，找到适当的位置。使用直接插入排序，对于具有n个记录的文件，要进行n-1趟排序。

代码如下:

void Dir_Insert(int A[],int N)  //直接插入排序
{
    int j,t;
    for(int i=1;i<N;i++)
    {
        t=A[i];
        j=i-1;
        while(A[j]>t)
        {
            A[j+1]=A[j];
            j--;
        }
        A[j+1]=t;
    }
}


②.希尔排序(不稳定)：
    希尔(Shell)排序的基本思想是：先取一个小于n的整数d1作为第一个增量把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取得第二个增量d2<d1重复上述的分组和排序，直至所取的增量di=1，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。
    一般取d1=n/2，di+1=di/2。如果结果为偶数，则加1，保证di为奇数。
    希尔排序是不稳定的，希尔排序的执行时间依赖于增量序列，其平均时间复杂度为O(n^1.3).

代码如下:

void Shell(int A[],int n)  //Shell排序
{
    int i,j,k,t;
    (n/2)%2 == 0 ? k = n/2+1 : k = n/2; //保证增量为奇数
    while(k > 0)
    {
        for(j=k;j<n; j++)
        {
            t = A[j];
            i = j - k;
            while(i>=0 && A[i]>t)
            {
                A[i+k]=A[i];
                i=i-k;
            }
            A[i+k]=t;
        }
        if(k == 1) break;
        (k/2)%2 ==0 ? k=k/2+1 : k=k/2;
    }
}


二.选择排序
    选择排序的基本思想是每步从待排序的记录中选出排序码最小的记录，顺序存放在已排序的记录序列的后面，直到全部排完。选择排序中主要使用直接选择排序和堆排序。
   
①.直接选择排序(不稳定)
    直接选择排序的过程是：首先在所有记录中选出序码最小的记录，把它与第1个记录交换，然后在其余的记录内选出排序码最小的记录，与第2个记录交换......依次类推，直到所有记录排完为止。
    无论文件初始状态如何，在第i趟排序中选出最小关键字的记录，需要做n-i次比较，因此，总的比较次数为n(n-1)/2=O(n^2)。当初始文件为正序时，移动次数为0；文件初态为反序时，每趟排序均要执行交换操作，总的移动次数取最大值3(n-1)。直接选择排序的平均时间复杂度为O(n^2)。直接选择排序是不稳定的。

代码如下:

void Dir_Choose(int A[],int n)  //直接选择排序
{
    int k,t;
    for(int i=0;i<n-1;i++)
    {
        k=i;
        for(int j=i+1;j<n;j++)
        {
            if(A[j]<A[k]) k=j;
        }
        if(k!=i)
        {
            t=A[i];
            A[i]=A[k];
            A[k]=t;
        }
    }
}


②.堆排序(不稳定)
    堆排序是一种树形选择排序，是对直接选择排序的有效改进。n个关键字序列
K1,K2,...,Kn称为堆，当且仅当该序列满足(Ki<=K2i且Ki<=K2i+1)或(Ki>=K2i且Ki>=K2i+1),(1<=i<=n/2)。根结点(堆顶)的关键字是堆里所有结点关键字中最小者，称为小根堆；根结点的关键字是堆里所有结点关键字中最大者，称为大根堆。
    若将此序列所存储的向量R[1..n]看作是一棵完全二叉树的存储结构，则堆实质上是满足如下性质的完全二叉树：树中任一非叶结点的关键字均不大于(或不小于)其左右孩子(若存在)结点的关键字。
    堆排序的关键步骤有两个：一是如何建立初始堆；二是当堆的根结点与堆的最后一个结点交换后，如何对少了一个结点后的结点序列做调整，使之重新成为堆。堆排序的最坏时间复杂度为O(nlog2n),堆排序的平均性能较接近于最坏性能。由于建初始堆所需的比较 次数较多，所以堆排序不适宜于记录较少的文件。堆排序是就地排序，辅助空间为O(1)，它是不稳定的排序方法。

代码略..


三.交换排序
    交换排序的基本思想是：两两比较待排序记录的排序码，并交换不满足顺序要求的那写偶对，直到满足条件为止。交换排序的主要方法有冒泡排序和快速排序.

①.冒泡排序(稳定的)
    冒泡排序将被排序的记录数组R[1..n]垂直排列，每个记录R[i]看作是重量为ki的气泡。根据轻气泡不能在重气泡之下的原则，从下往上扫描数组R；凡扫描到违反本原则的轻气泡，就使其向上"漂浮"。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。
    冒泡排序的具体过程如下：
    第一步，先比较k1和k2，若k1>k2，则交换k1和k2所在的记录，否则不交换。继续对k2和k3重复上述过程，直到处理完kn-1和kn。这时最大的排序码记录转到了最后位置，称第1次起泡，共执行n-1次比较。
    与第一步类似，从k1和k2开始比较，到kn-2和kn-1为止，共执行n-2次比较。
    依次类推，共做n-1次起泡，完成整个排序过程。
    若文件的初始状态是正序的，一趟扫描即可完成排序。所需关键字比较次数为n-1次，记录移动次数为0。因此，冒泡排序最好的时间复杂度为O(n)。
    若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i次关键字的比较(1<=i<=n-1),且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较次数达到最大值n(n-1)/2=O(n^2),移动次数也达到最大值3n(n-1)/2=O(n^2)。因此，冒泡排序的最坏时间复杂度为O(n^2)。
    虽然冒泡排序不一定要进行n-1趟，但由于它的记录移动次数较多，故平均性能比直接插入排序要差得多。冒泡排序是就地排序，且它是稳定的。

代码如下:

void QP(int A[],int n)  //优化的冒泡排序
{
    int count=0,t,flag;
    for(int i=0;i<n-1;i++)
    {
        flag=0;
        for(int j=0;j<n-i;j++)
        {
            if(A[j+1]<A[j])
            {
                t=A[j];
                A[j]=A[j+1];
                A[j+1]=t;
                flag=1;
                count+=3;
            }
        }
        if(flag==0) break;
    }
}


②.快速排序：(不稳定的)
    快速排序采用了一种分治的策略，通常称其为分治法，其基本思想是：将原问题分解为若干个规模更小但结构与原问题相似的子问题。递归地解这些子问题，然后将这些子问题的解组合为原问题的解。
    快速排序的具体过程如下：
    第一步，在待排序的n个记录中任取一个记录，以该记录的排序码为准，将所有记录分成两组，第1组各记录的排序码都小于等于该排序码，第2组各记录的排序码都大于该排序码，并把该记录排在这两组中间。
    第二步，采用同样的方法，对左边的组和右边的组进行排序，直到所有记录都排到相应的位置为止。

代码如下:

void Quick_Sort(int A[],int low,int high)  //low和high是数组的下标
{
    if(low<high)
    {
        int temp,t=A[low];
        int l=low,h=high;
        while(l<h)
        {
            while(A[l]<t) l++;
            while(A[h]>=t) h--;
            if(h>l)
            {
                temp=A[l];
                A[l]=A[h];
                A[h]=temp;
            }
        }
        Quick_Sort(A,low,l-1);
        Quick_Sort(A,l+1,high);
    }
}


四.归并排序
    归并排序是将两个或两个以上的有序子表合并成一个新的有序表。初始时，把含有n个结点的待排序序列看作由n个长度都为1的有序子表组成，将它们依次两两归并得到长度为2的若干有序子表，再对它们两两合并。直到得到长度为n的有序表，排序结束。
    归并排序是一种稳定的排序，可用顺序存储结构，也易于在链表上实现，对长度为n的文件，需进行log2n趟二路归并，每趟归并的时间为O(n),故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlog2n)。归并排序需要一个辅助向量来暂存两个有序子文件归并的结果，故其辅助空间复杂度为O(n),显然它不是就地排序。

代码略...



五.基数排序
设单关键字的每个分量的取值范围均是C0<=Kj<=Crd-1(0<=j<=rd),可能的取值个数rd称为基数．基数的选择和关键字的分解因关键字的类型而异．
　　(1).若关键字是十进制整数，则按个、十等位进行分解，基数rd=10,C0=0,C9=9,d为最长整数的位数．
　　(2).若关键字是小写的英文字符串，则rd=26,C0='a',C25='z',d为最长字符串的长度．
　　基数排序的基本思想是：从低位到高位依次对待排序的关键码进行分配和收集，经过d趟分配和收集，就可以得到一个有序序列．





按平均时间将排序分为四类：

（1）平方阶(O(n2))排序
    　一般称为简单排序，例如直接插入、直接选择和冒泡排序；

（2）线性对数阶(O(nlgn))排序
    　如快速、堆和归并排序；

（3）O(n1+￡)阶排序
    　￡是介于0和1之间的常数，即0<￡<1，如希尔排序；

（4）线性阶(O(n))排序
    　如基数排序。

各种排序方法比较
     简单排序中直接插入最好，快速排序最快，当文件为正序时，直接插入和冒泡均最佳。

影响排序效果的因素
   　因为不同的排序方法适应不同的应用环境和要求，所以选择合适的排序方法应综合考虑下列因素：
　　①待排序的记录数目n；
　　②记录的大小(规模)；
　　③关键字的结构及其初始状态；
　　④对稳定性的要求；
　　⑤语言工具的条件；
　　⑥存储结构；
　　⑦时间和辅助空间复杂度等。

不同条件下，排序方法的选择

(1)若n较小(如n≤50)，可采用直接插入或直接选择排序。
    　当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。
(2)若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；
(3)若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或
归并排序。
    快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
    堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的。
    若要求排序稳定，则可选用归并排序。但从单个记录起进行两两归并的  排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。
