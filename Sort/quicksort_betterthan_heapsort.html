<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-us"><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>quicksort_betterthan_heapsort</title><meta content="Juniway" name="author"></head><body><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">Empirical studies show that generally quick sort is considerably faster than heapsort<br>.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">The
following counts of compare and exchange operations were made for three
different sorting algorithms running on the same data:</p><center style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><table border="1"><tbody><tr><th rowspan="2"><i>n</i></th><th colspan="2">Quick</th><th colspan="2">Heap</th><th colspan="2">Insert</th></tr><tr><th>Comparison</th><th>Exchange</th><th>Comparison</th><th>Exchange</th><th>Comparison</th><th>Exchange</th></tr><tr><td align="center">100</td><td align="center">712</td><td align="center">148</td><td align="center">2,842</td><td align="center">581</td><td align="center">2,595</td><td align="center">899</td></tr><tr><td align="center">200</td><td align="center">1,682</td><td align="center">328</td><td align="center">9,736</td><td align="center">1,366</td><td align="center">10,307</td><td align="center">3,503</td></tr><tr><td align="center">500</td><td align="center">5,102</td><td align="center">919</td><td align="center">53,113</td><td align="center">4,042</td><td align="center">62,746</td><td align="center">21,083</td></tr></tbody></table></center><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">Thus, when an occasional "blowout" to<span class="Apple-converted-space">&nbsp;</span><b>O(<i>n</i><sup>2</sup>)</b><span class="Apple-converted-space">&nbsp;</span>is
tolerable, we can expect that, on average, quick sort will provide
considerably better performance - especially if one of the modified
pivot choice procedures is used.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">Most
commercial applications would use quicksort for its better average
performance: they can tolerate an occasional long run (which just means
that a report takes slightly longer to produce on full moon days in
leap years) in return for shorter runs most of the time.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">However, quick sort should<span class="Apple-converted-space">&nbsp;</span><b><font color="red">never</font></b><span class="Apple-converted-space">&nbsp;</span>be used in applications which require a guarantee of response time, unless it is treated as an<span class="Apple-converted-space">&nbsp;</span><b>O(<i>n</i><sup>2</sup>)</b><span class="Apple-converted-space">&nbsp;</span>algorithm in calculating the worst-case response time. If you have to assume<span class="Apple-converted-space">&nbsp;</span><b>O(<i>n</i><sup>2</sup>)</b><span class="Apple-converted-space">&nbsp;</span>time, then - if<span class="Apple-converted-space">&nbsp;</span><b>n</b><span class="Apple-converted-space">&nbsp;</span>is small, you're better off using insertion sort - which has simpler code and therefore smaller constant factors.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">And if<span class="Apple-converted-space">&nbsp;</span><b>n</b><span class="Apple-converted-space">&nbsp;</span>is large, you should obviously be using heap sort, for its<span class="Apple-converted-space">&nbsp;</span><i>guaranteed</i><span class="Apple-converted-space">&nbsp;</span><b>O(nlog n)</b><span class="Apple-converted-space">&nbsp;</span>time.
Life-critical (medical monitoring, life support in aircraft and space
craft) and mission-critical (monitoring and control in industrial and
research plants handling dangerous materials, control for aircraft,
defence, etc) software will generally have a response time as part of
the system specifications. In all such systems, it is not acceptable to
design based on average performance, you must always allow for the
worst case, and thus treat quicksort as<span class="Apple-converted-space">&nbsp;</span><b>O(n<sup>2</sup>)</b>.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">So far, our best sorting algorithm has<span class="Apple-converted-space">&nbsp;</span><b>O(<i>n</i>log<span class="Apple-converted-space">&nbsp;</span><i>n</i>)</b><span class="Apple-converted-space">&nbsp;</span>performance: can we do any better?</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"><i>In general,</i><span class="Apple-converted-space">&nbsp;</span>the answer is<span class="Apple-converted-space">&nbsp;</span><b><font color="red">no</font></b>.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">However, if we know something about the items to be sorted, then we may be able to do better.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">But first, we should look at squeezing the last drop of performance out of quicksort.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"></p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">The recursive calls in quick sort are generally expensive on most architectures - the overhead of<span class="Apple-converted-space">&nbsp;</span><i>any</i><span class="Apple-converted-space">&nbsp;</span>procedure call is significant and reasonable improvements can be obtained with equivalent<span class="Apple-converted-space">&nbsp;</span><font color="#fa0000">iterative algorithms</font>.</p><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;">Two things can be done to eke a little more performance out of your processor when sorting:</p><ol style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;" type="a"><li>Quick sort - in its usual recursive form - has a reasonably high constant factor relative to a simpler sort such as<span class="Apple-converted-space">&nbsp;</span><a href="http://www.cs.auckland.ac.nz/%7Ejmor159/PLDS210/sorting.html">insertion sort</a>. Thus, when the partitions become small (<b><i>n</i><span class="Apple-converted-space">&nbsp;</span>&lt; ~10</b>),
a switch to insertion sort for the small partition will usually show a
measurable speed-up. (The point at which it becomes effective to switch
to the insertion sort is extremely sensitive to architectural features
and needs to be determined for any target processor: although a value
of ~10 is a reasonable guess!)</li><li>Write the whole algorithm in an iterative form. This is left for a tutorial exercise!</li></ol><p style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px;"></p></body></html>