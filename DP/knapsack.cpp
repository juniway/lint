01背包问题描述
已知:有一个容量为V的背包和N件物品，第i件物品的重量是weight[i]，收益是cost[i]。
限制:每种物品只有一件，可以选择放或者不放
问题:在不超过背包容量的情况下，最多能获得多少价值或收益
相似问题:在恰好装满背包的情况下，最多能获得多少价值或收益
这里，我们先讨论在不超过背包容量的情况下，最多能获得多少价值或收益。

子问题定义状态: f[i][v] : 前i件物品放到一个容量为v的背包中可以获得最大价值  
状态转移方程: f[i][v] = max(f[i - 1][v],f[i - 1][v - weight[i]] + cost[i])
分析

考虑我们的子问题，将前i件物品放到容量为v的背包中，
若我们只考虑第i件物品时，它有两种选择，放或者不放。
1) 如果第i件物品不放入背包中，那么问题就转换为：
	将前i - 1件物品放到容量为v的背包中，带来的收益f[i - 1][v]
2) 如果第i件物品能放入背包中，那么问题就转换为：
	将前i - 1件物品放到容量为v - weight[i]的背包中，带来的收益f[i - 1][v - weight[i]] + cost[i]


#include <iostream>
using namespace std;

const int N = 3; // 物品个数
const int V = 5; // 背包最大容量
int weight[N + 1] = {0, 3, 2, 2};	// 物品重量
int value[N + 1] = {0, 5, 10, 20};	// 物品价值

int f[N + 1][V + 1] = {{0}};
/*
目标：在不超过背包容量的情况下，最多能获得多少价值
子问题状态:f[i][j]:表示前i件物品放入容量为j的背包得到的最大价值
状态转移方程:f[i][j] = max{f[i - 1][j],f[i - 1][j - weight[i]] + value[i]}
初始化:f数组全设置为0
*/

效率分析：
此算法的时间复杂度为O(N*V)，空间复杂度也为O(N*V)。
其中，N 表示物品个数，V 表示背包容量这里，时间复杂度不可以在优化了，
但是空间复杂度可以继续优化到O(V)

int Knapsack(){
	memset(f,0,sizeof(f));
	for(int i = 1; i <= N; i++){
		for(int j = 0; j <= V; j++){	// 枚举背包容量
			f[i][j] = f[i - 1][j];
			if (j >= weight[i]){
				f[i][j] = max(f[i - 1][j],f[i - 1][j - weight[i]] + value[i]);
			}
		}
	}
	return f[N][V];
}

