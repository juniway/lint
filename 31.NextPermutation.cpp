

 解题思想：

所谓一个排列的下一个排列的意思就是 这一个排列与下一个排列之间没有其他的排列。
这就要求这一个排列与下一个排列有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。
可能理解起来比较难懂。
对于数字序列：
    [7,    8,     6,     9,     8,    7,    2]
    	                 ^
    	 		A[i]  A[i+1]

    [7,    8,     7,     9,     8,    6,    2] Wrong!

    [7,    8,     7,     2,     6,    8,    9] Correct!
           

先看前面2排的话，可以看出来第二排是比第一排要大的，参考字符串比较大小的问题。
那么第2个排列是不是第一个排列的下一个排列呢。很明显不是，第3个排列才是， 

那么如何获取到下一个排列呢。步骤比较简单：假设数组大小为 n
1.从后往前，找到第一个 A[i] < A[i+1]的。也就是第一个排列中的6，
可以看到A[i+1]到A[n-1]这些都是单调递减序列。
2.从后往前，直到到A[i+1]为止，找到第一个比A[i]大的值（必须是大于，不能等于）, 记为A[j]。 
（也就是说在A[n-1]到A[i+1]的值中找到比A[i]大的最小的一个值, 
swap(A[i], A[j]), 并且把A[i+1]到A[n-1] 按从小到大排序。
由于这一步是在排好序的A[i+1, n-1]中查找，所以可以Binary Search,更快。

4. 如果不存在A[i] < A[i+1], 即i 遍历到0之后还没有找到，那么就把原序列头尾对调swap(i, n-1-i);

函数实现原理如下：
	在当前序列中，从尾端往前寻找两个相邻元素，前一个记为*i，后一个记为*ii，并且满足*i < *ii。
	然后再从尾端往前寻找另一个元素*j，	如果满足*i < *j，即将第i个元素与第j个元素对调，
	并将第ii个元素之后（包括ii）的所有元素颠倒排序，即求出下一个序列了。

class Solution {
public:
	void nextPermutation(vector<int> &A){
	    int n = A.size();
	    if(n < 2) return;
        int j = n-2;
        while(j >= 0 && A[j] >= A[j+1]) j--;
        
        if(j < 0) {
            sort(A.begin(), A.end());
            return;
        } 
        
        int i = j + 1;
        while(i < n && A[i] > A[j]) i++;
        i--;
        
        swap(A[i], A[j]);
        sort(A.begin()+j+1, A.end());
	}
};

// Note:
// 在C++的标准库中有“求一个数字序列的下一个排列”的库函数叫 next_permutation(),
// 可以实现下一个排列的功能。
// 当然这种函数在A题的时候是可以用的，但是在面试的时候直接调用是不行的。

void nextPermutation(vector<int> &A){
    next_permutation(A.begin(), A.end());
}

